AutoGen Definitions strings;
/* -*- Mode: C -*- */
/**
 * \file map-text.def
 *
 *  This file is part of char-mapper.
 *  Copyright (C) 2003-2020 by Bruce Korb - all rights reserved
 *
 * char-mapper is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * char-mapper is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

string = { nm = bad_directive;  str = "invalid directive: %s\n"; };
string = { nm = guard_fmt;      str = "%s_GUARD"; };
string = { nm = define_fmt;     str = "DEFINE_%s"; };
string = { nm = typedef_mask;   str = "\ntypedef %s %s;\n\n"; };
string = { nm = declare_tbl;    str = "extern %s const %s[%d];\n"; };
string = { nm = opterrmsg;      str = "char-mapper error:  %s:  %s\n"; };
string = { nm = input_is_tty;   str  = "input is from a TTY"; };
string = { nm = table_sfx;      str  = "_table"; };
string = { nm = must_be_file;   str  = "device must be file or pipe"; };

string = { nm = leader_fmt;
  str = <<- _EOString_
	/*
	 *  %1$u bits for %2$u character classifications
	 *  generated by %7$s on %3$s
	 *
	%4$s */
	#ifndef %5$s
	#define %5$s 1

	#ifdef HAVE_CONFIG_H
	# if defined(HAVE_INTTYPES_H)
	#   include <inttypes.h>

	# elif defined(HAVE_STDINT_H)
	#   include <stdint.h>

	%6$s
	# endif /* HAVE_*INT*_H header */

	#else /* not HAVE_CONFIG_H -- */
	# include <inttypes.h>
	#endif /* HAVE_CONFIG_H */

	_EOString_;
};

string = { nm = type_8bits;
  str  = <<- _EOString_
	#   elif !defined(HAVE_UINT8_T)
	        typedef unsigned char   uint8_t;
	_EOString_;
};

string = { nm = type_16bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT16_T)
	    typedef unsigned short  uint16_t;
	_EOString_;
};

string = { nm = type_32bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT32_T)
	#   if SIZEOF_INT == 4
	      typedef unsigned int    uint32_t;
	#   elif SIZEOF_LONG == 4
	      typedef unsigned long   uint32_t;
	#   endif
	_EOString_;
};

string = { nm = type_64bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT64_T)
	#   if SIZEOF_LONG == 8
	      typedef unsigned long       uint64_t;
	#   elif SIZEOF_LONG_LONG == 8
	      typedef unsigned long long  uint64_t;
	#   endif
	_EOString_;
};

string = { nm = declare_opt_tbl;
  str = <<- _EOString_
	extern %1$s const %2$s_table[%3$d];
	extern unsigned char const * %2$s_spanners[%5$u];
	extern unsigned char const *
	calc_%2$s_spanners(unsigned int mask_ix);


	_EOString_;
};

string = { nm = inline_opt_functions;
  str = <<- _EOString_
	static inline int
	is_%1$s_char(char ch, %2$s mask)
	{
	    unsigned int ix = (unsigned char)ch;
	    return ((ix < %3$d) && ((%1$s_table[ix] & mask) != 0));
	}

	static inline char *
	spn_%1$s_chars(char const * p, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    while (v[(unsigned char)*p])  p++;
	    return (char *)(uintptr_t)p;
	}

	static inline char *
	brk_%1$s_chars(char const * p, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    while ((*p != '\0') && (! v[(unsigned char)*p]))  p++;
	    return (char *)(uintptr_t)p;
	}

	_EOString_;
};

string = { nm = inline_opt_backup;
  str = <<- _EOString_

	static inline char *
	spn_%1$s_back(char const * s, char const * e, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    if (s >= e) e = s + strlen(s);
	    while ((e > s) && v[(unsigned char)e[-1]])  e--;
	    return (char *)(uintptr_t)e;
	}

	static inline char *
	brk_%1$s_back(char const * s, char const * e, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    if (s == e) e += strlen(e);
	    while ((e > s) && (! v[(unsigned char)e[-1]]))  e--;
	    return (char *)(uintptr_t)e;
	}

	_EOString_;
};

string = { nm = inline_functions;
  str = <<- _EOString_
	static inline int
	is_%1$s_char(char ch, %2$s mask)
	{
	    unsigned int ix = (unsigned char)ch;
	    return ((ix < %3$d) && ((%4$s[ix] & mask) != 0));
	}

	static inline char *
	spn_%1$s_chars(char const * p, %2$s mask)
	{
	    while ((*p != '\0') && is_%1$s_char(*p, mask))  p++;
	    return (char *)(uintptr_t)p;
	}

	static inline char *
	brk_%1$s_chars(char const * p, %2$s mask)
	{
	    while ((*p != '\0') && (! is_%1$s_char(*p, mask)))  p++;
	    return (char *)(uintptr_t)p;
	}

	_EOString_;
};

string = { nm = inline_backup;
  str = <<- _EOString_

	static inline char *
	spn_%1$s_back(char const * s, char const * e, %2$s mask)
	{
	    if (s >= e) e = s + strlen(s);
	    while ((e > s) && is_%1$s_char(e[-1], mask))  e--;
	    return (char *)(uintptr_t)e;
	}

	static inline char *
	brk_%1$s_back(char const * s, char const * e, %2$s mask)
	{
	    if (s == e) e += strlen(e);
	    while ((e > s) && (! is_%1$s_char(e[-1], mask)))  e--;
	    return (char *)(uintptr_t)e;
	}

	_EOString_;
};

/*
 * "extra" text requested to be included in the output.
 */
string = { nm = emit_text_fmt;    str = "\n/* emit text from map file: */"
           "\n\n%s\n"; };
string = { nm = static_table_fmt; str = "static %s const %s[%d] = {\n "; };
string = { nm = table_fmt;        str = "#ifdef %s\n%s const %s[%d] = {\n "; };
string = { nm = no_locking;       str = "};\n#undef LOCK_SPANNER_TABLES\n"; };

string = { nm = optimize_fmt;
  str = <<- _EOString_

	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>

	#ifndef _
	# define _(_s) _s
	#endif

	%1$sunsigned char const * %2$s_spanners[%3$u];
	/**
	 *  Character category masks.  Some categories may have multiple bits,
	 *  if their definition incorporates other character categories.
	 *  This mask array is only used by calc_%2$s_spanners().
	 */
	static %2$s_mask_t const %2$s_masks[%3$u] = {

	_EOString_;
};

string = { nm = pthread_locking;
  str = <<- _EOString_
	};

	#include <pthread.h>
	static pthread_mutex_t %1$s_mutex = PTHREAD_MUTEX_INITIALIZER;
	#define LOCK_SPANNER_TABLES 1

	_EOString_;
};

string = { nm = fill_opt_fmt;
  str = <<- _EOString_

	%2$sunsigned char const *
	calc_%1$s_spanners(unsigned int mask_ix)
	{
	#ifdef LOCK_SPANNER_TABLES
	    if (%1$s_spanners[mask_ix] != NULL)
	        return %1$s_spanners[mask_ix];

	    pthread_mutex_lock(&%1$s_mutex);
	    if (%1$s_spanners[mask_ix] == NULL)
	#endif
	    {
	        int ix = 1;
	        %1$s_mask_t mask = %1$s_masks[mask_ix];
	        unsigned char * res = malloc(256 /* 1 << NBBY */);
	        if (res == NULL) {
	            fputs(_("no memory for char-mapper span map\n"), stderr);
	            exit(EXIT_FAILURE);
	        }

	        memset(res, 0, 256);
	        for (; ix < 128; ix++)
	            if (%1$s_table[ix] & mask)
	                res[ix] = 1;
	        %1$s_spanners[mask_ix] = res;
	    }
	#ifdef LOCK_SPANNER_TABLES
	    pthread_mutex_unlock(&%1$s_mutex);
	#endif
	    return %1$s_spanners[mask_ix];
	}
	#define %1$s_masks POISONED_%1$s_masks


	_EOString_;
};

/*
 * start and end of the copy of the input as a comment.
 */
string = { nm = copy_input_start;
  str = "\n#if 0 /* mapping specification source (from %s) */\n";
};

string = { nm = copy_input_end;
  str = "//\n#endif /* 0 -- mapping spec. source */\n\n";
};

string = { nm = macro_def_fmt;
  str = "#define  IS_%1$s_CHAR( _c)%2$s  is_%3$s_char((char)(_c), %4$s)\n"
        "#define SPN_%1$s_CHARS(_s)%2$s spn_%3$s_chars(_s, %5$s)\n"
        "#define BRK_%1$s_CHARS(_s)%2$s brk_%3$s_chars(_s, %5$s)\n";
};

string = { nm = backup_def_fmt;
  str = "#define SPN_%1$s_BACK(s,e)%2$s spn_%3$s_back(s, e, %4$s)\n"
        "#define BRK_%1$s_BACK(s,e)%2$s brk_%3$s_back(s, e, %4$s)\n";
};

string = { nm = mask_fmt_fmt;       str = "0x%%0%dX"; };
string = { nm = char_map_gd;        str = "CHAR_MAPPER_H_GUARD"; };
string = { nm = end_table;          str = "\n};\n"; };
string = { nm = endif_fmt;          str = "#endif /* %s */\n"; };
string = { nm = tname_fmt;          str = "%s_table"; };
string = { nm = testit_class_names; str = "\n        \"%02X == %s\\n\""; };
string = { nm = testit_class_hdrs;  str = "\n        \"char is: "; };

/*
 * Test main procedure formatting:
 */
string = { nm = testit_fmt;
  str = <<- _EOString_

	#ifdef TEST_%s
	int main (int argc, char ** argv) {
	    int ix = 0;
	    static char const header[] =
	_EOString_;
};

string = { nm = test_loop;
  str = <<- _EOString_
	\n";
	    fwrite(header, sizeof(header)-1, 1, stdout);

	    for (; ix<128; ix++) {
	        char ch = ((ix >= 0x20) && (ix < 0x7F)) ? ix : '?';
	        printf("0x%02X (%c) ", ix, ch);

	_EOString_; /* " */
};

string = { nm = each_test;
  str = "        putchar(' '); putchar(' ');\n"
        "        putchar(is_%s_char((char)ix, %s) ? 'X' : '.');\n";
};

string = { nm = endtest_fmt;
  str = <<- _EOString_
	    }
	    return 0;
	}
	#endif /* TEST_%s */

	_EOString_;
};

string = { nm = test_script_fmt;
  str = <<- _EOString_
	#if 0
	##  process this file with bash to test the classification result
	##  /usr/include/inttypes.h must exist
	base=%1$s-$$
	cfil=${base}.c
	set -e
	trap "rm -f ${base}*" EXIT
	cat > ${cfil} <<\_EOCode_
		#define TEST_%2$s         1
		#define DEFINE_%2$s_TABLE 1
		#define _GNU_SOURCE 1
		#include "%3$s"
		_EOCode_

	${CC:-cc} -o ${base} ${base}.c
	./${base}
	rm -f ${base}*
	exit 0
	#endif

	_EOString_;
};

/*
 *  Usage text gets extracted from char-mapper.c into this ".def" file.
 */
string = { nm = usage_text;
#include cm-usage-text.def
};
